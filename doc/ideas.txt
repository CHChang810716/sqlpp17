Value types:
============
sqlpp11 has types like integral, text, boolean, etc. The library needs to define in much detail
how these types interact.

sqlpp17 simply uses whatever type you want.


Columns and tables:
===================
#warning: To check if all columns are correct, we should compare provided and required columns
#warning: (column being defined by TableSpec and ColumnSpec).

Difficult decision:
Tables and alias tables are defined by name and columns.
Columns /could/ be defined by tables and column specifications.
In that case they could uniquely identified. However, it would require
columns types to contain the table type, which contains all column
specifications.
Thus, `select(all_of(tab))` would contain all columns, each of which
would contain all column specs. This is quadratic in the number of
columns. That seems non-sustainable.

It seems more reasonable to just store the tables spec in the column
type and then look for required and provided columns.

Now, this would allow for

```
select(foo.id).from(bar.as(foo))
```

if `bar` happens to have an `id` column like `foo`.

While this construed example looks bad, I believe it is rather unlikely to happen.
I am therefore willing to risk that in favor of quadraticly growing type names.


No "dynamic_select" et al.
==========================
In sqlpp11, we can add tables dynamically to the right. We can combine conditions dynamically via AND.
In sqlpp17, we can anonymize tables/joins and expressions so that we can combine static and dynamic parts more fluently.

There will also be several versions of select: With a static tuple, or with a vector of variants of fields.


vector of variants, pros and cons:
----------------------------------
It would be a variant of things that represent named value types. We could add any number of these in a vector.

Pros:
- we could dynamically select ANY number of columns
- we could use ANY name
- access in vector or map pattern

Cons:
- very different interface from the static one
- values need to be anonymized (type-erased) -> statement cannot be used for more than one db
- we could get index/name wrong when obtaining results
- we could get the type wrong (bad_variant exception)

Using optional for those things that are optional but static in nature:
-----------------------------------------------------------------------
Columns can be optional in a select, but they themselves are static.
Tables can be optional in a join, but they themselves are static.

Most of the time, anyway.

Thus, with 

{{{
		auto make_optbool useOption, Expression e)
		{
			if (useOption)
				return std::optional<Expression>{e};
			else
				return std::optional<Expression>{};
		}
}}}

we could say something like :

    select(t.foo, make_opt(wantBar, f.bar))
        .from(t.join(make_opt(wantBar, f).on(t.fId = f.id)))
        .unconditionally();

All compile time checks are made as if all conditionals actually hold a value. 
Optional columns will always yield NULL (no database interaction).
Optional joins will not be serialized

providing flags and columns:
============================
select(all_of(t)).flags(sqlpp::distinct)...

or 

select(sqlpp::distinct).columns(all_of(t))...

or

select().flags(sqlpp::distinct).columns(all_of(t))...

The nicest way would still be to just say

select(sqlpp::distinct, all_of(t))...

That also happens to be the hardest way to do it (haven't found a nice solution yet)

row.x should be a value/optional, not a complex object.
=======================================================
auto x = row.x leads to too many surprises

results.front() needs to throw is results.empty()
=================================================
It happens way too often that someone assumes that there is at least one result, when there isn't

Instead of having a "custom_statement", combine statements with operator<< or similar

Braces:
=======
Use braces only if needed, e.g. not for "x and y and z" but for "(x or y) and z". Same with +-*/.

Actually, quite simple: no braces for chaining "same" operators, any other combination requires braces.

Invert the logic from sqlpp11: Instead of expressions writing braces for themselves, request braces for subexpressions where they might be required.

TrivialIsNull:
==============
This was one of the most controversial ideas in sqlpp11.

Today, I agree with the critics: this requires the library to do so much "magic", it is just confusing.

Custom statements:
==================
These can be created trivially by concatenating sub-statements.

Union:
======
"merge" field specs: if left can be null while right cannot, then union can be null
union() takes two or more select statements (the member function could forward to a free function)

CTE:
====
CTEs can be self-referential. In order to do that, we need to know the columns of a CTE.

Thus, we need to create the non-recursive part first and then union-all with the second part.
