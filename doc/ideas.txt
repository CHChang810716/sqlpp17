No "dynamic_select" et al.
==========================
In sqlpp11, we can add tables dynamically to the right. We can combine conditions dynamically via AND.
In sqlpp17, we can anonymize tables/joins and expressions so that we can combine static and dynamic parts more fluently.

There will also be several versions of select: With a static tuple, or with a vector of variants of fields.

row.x should be a value/optional, not a complex object.
=======================================================
auto x = row.x leads to too many surprises

std::optional is not good if "trivial_is_null", though.

Need something that represents a value and offers is_null.

results.front() needs to throw is results.empty()
=================================================
It happens way too often that someone assumes that there is at least one result, when there isn't

Instead of having a "custom_statement", combine statements with operator<< or similar

Braces:
=======
Use braces only if needed, e.g. not for "x and y and z" but for "(x or y) and z". Same with +-*/.

Actually, quite simple: no braces for chaining "same" operators, any other combination requires braces.

Invert the logic from sqlpp11: Instead of expressions writing braces for themselves, request braces for subexpressions where they might be required.

TrivialIsNull:
==============
Evaluate "trivial_is_null" in a "if constexpr" instead of wrapping it in a type as in sqlpp11.

Custom statements:
==================
These can be created trivially by concatenating sub-statements.

Union:
======
"merge" field specs: if left can be null while right cannot, then union can be null
union() takes two or more select statements (the member function could forward to a free function)
